"""
Data submission operations for Joget forms.

Provides API-based data submission with batch support and infrastructure
field validation.
"""

import logging
from typing import Any, Callable

from ..exceptions import ValidationError
from ..models import DataSubmissionResult

logger = logging.getLogger(__name__)


# Infrastructure fields that Joget auto-generates (must NOT be submitted)
INFRASTRUCTURE_FIELDS = {
    "id",
    "dateCreated",
    "dateModified",
    "createdBy",
    "modifiedBy",
    "createdByName",
    "modifiedByName",
}


class DataOperations:
    """
    Mixin providing data submission operations.

    This mixin requires the class to have:
    - self.post(endpoint, **kwargs) -> dict
    - self.config
    - self.logger

    Example:
        >>> from joget_deployment_toolkit import JogetClient
        >>> client = JogetClient.from_instance("jdx4")
        >>> result = client.submit_form_data(
        ...     form_id="md01maritalStatus",
        ...     data={"code": "single", "name": "Single"},
        ...     api_id="API-b81e5d88-..."
        ... )
        >>> print(f"Created: {result.record_id}")
    """

    def submit_form_data(
        self,
        form_id: str,
        data: dict[str, Any],
        *,
        api_id: str,
        api_key: str | None = None,
    ) -> DataSubmissionResult:
        """
        Submit single record to form via API.

        Uses Joget's form API endpoint: /api/form/{form_id}/saveOrUpdate

        IMPORTANT: Do NOT include infrastructure fields in data:
        - id (auto-generated by Joget)
        - dateCreated, dateModified (set by Joget)
        - createdBy, modifiedBy (set from current user)
        - createdByName, modifiedByName (set from user profile)

        Args:
            form_id: Form identifier (e.g., "md01maritalStatus")
            data: Record data (business fields only)
            api_id: API ID for the form endpoint
            api_key: Optional API key override

        Returns:
            DataSubmissionResult with success status, record ID, message

        Raises:
            ValidationError: If data contains infrastructure fields
            NotFoundError: If form or API endpoint doesn't exist
            JogetAPIError: On API errors

        Example:
            >>> result = client.submit_form_data(
            ...     form_id="md01maritalStatus",
            ...     data={"code": "single", "name": "Single"},
            ...     api_id="API-b81e5d88-b747-476a-92d3-0aac6bb1f0f3"
            ... )
            >>> if result.success:
            ...     print(f"Created: {result.record_id}")
        """
        # Validate: no infrastructure fields
        invalid_fields = set(data.keys()) & INFRASTRUCTURE_FIELDS
        if invalid_fields:
            raise ValidationError(
                f"Data contains infrastructure fields that Joget auto-generates: "
                f"{', '.join(sorted(invalid_fields))}. Remove these fields before submission."
            )

        # POST to form API
        endpoint = f"/api/form/{form_id}/saveOrUpdate"

        if self.config.debug:
            self.logger.debug(
                f"Submitting data to {form_id}: {list(data.keys())} fields"
            )

        try:
            response = self.post(
                endpoint,
                json=data,
                api_id=api_id,
                api_key=api_key,
            )

            # Parse response
            # Joget API may return different formats depending on version
            if isinstance(response, dict):
                success = response.get("success", True)
                record_id = response.get("id") or response.get("recordId")
                message = response.get("message")
                raw_data = response
            else:
                # If response is not a dict, assume success (some APIs return empty)
                success = True
                record_id = None
                message = "Submission completed"
                raw_data = {"response": response}

            result = DataSubmissionResult(
                success=success,
                record_id=record_id,
                message=message,
                raw_data=raw_data,
            )

            if self.config.debug:
                self.logger.debug(f"Submission result: {result}")

            return result

        except Exception as e:
            self.logger.error(f"Failed to submit data to {form_id}: {e}")
            return DataSubmissionResult(
                success=False,
                record_id=None,
                message=str(e),
                raw_data={"error": str(e), "form_id": form_id},
            )

    def submit_form_data_batch(
        self,
        form_id: str,
        records: list[dict[str, Any]],
        *,
        api_id: str,
        api_key: str | None = None,
        progress_callback: Callable[[int, int, DataSubmissionResult], None] | None = None,
        stop_on_error: bool = False,
    ) -> list[DataSubmissionResult]:
        """
        Submit multiple records to form via API.

        Submits records one by one with error handling.
        By default, failed records don't stop the batch (resilient mode).

        Args:
            form_id: Form identifier
            records: List of record data dicts
            api_id: API ID for the form endpoint
            api_key: Optional API key override
            progress_callback: Optional callback(current, total, result)
            stop_on_error: Stop processing if a record fails (default: False)

        Returns:
            List of DataSubmissionResult for each record

        Example:
            >>> records = [
            ...     {"code": "single", "name": "Single"},
            ...     {"code": "married", "name": "Married"}
            ... ]
            >>> results = client.submit_form_data_batch(
            ...     form_id="md01maritalStatus",
            ...     records=records,
            ...     api_id="API-...",
            ...     progress_callback=lambda i, t, r: print(f"{i}/{t}: {r}")
            ... )
            >>> successful = sum(1 for r in results if r.success)
            >>> print(f"Submitted {successful}/{len(records)} records")
        """
        results = []
        total = len(records)

        if self.config.debug:
            self.logger.debug(
                f"Starting batch submission: {total} records to {form_id}"
            )

        for i, record in enumerate(records, 1):
            try:
                result = self.submit_form_data(
                    form_id=form_id,
                    data=record,
                    api_id=api_id,
                    api_key=api_key,
                )
                results.append(result)

                if progress_callback:
                    progress_callback(i, total, result)

                # Stop on error if requested
                if stop_on_error and not result.success:
                    self.logger.warning(
                        f"Stopping batch after record {i}/{total} failed: {result.message}"
                    )
                    break

            except Exception as e:
                # Create error result but continue unless stop_on_error
                error_result = DataSubmissionResult(
                    success=False,
                    record_id=None,
                    message=str(e),
                    raw_data={"error": str(e), "record": record, "index": i},
                )
                results.append(error_result)

                if progress_callback:
                    progress_callback(i, total, error_result)

                self.logger.warning(
                    f"Failed to submit record {i}/{total} for {form_id}: {e}"
                )

                if stop_on_error:
                    self.logger.warning("Stopping batch due to error")
                    break

        # Summary logging
        successful = sum(1 for r in results if r.success)
        failed = sum(1 for r in results if not r.success)

        self.logger.info(
            f"Batch submission complete: {successful}/{total} successful, "
            f"{failed} failed for {form_id}"
        )

        return results

    def validate_data_for_submission(
        self, data: dict[str, Any], *, form_id: str = "form"
    ) -> None:
        """
        Validate that data doesn't contain infrastructure fields.

        Raises ValidationError if infrastructure fields are found.

        Args:
            data: Data to validate
            form_id: Form ID for error messages

        Raises:
            ValidationError: If data contains infrastructure fields

        Example:
            >>> data = {"code": "single", "name": "Single"}
            >>> client.validate_data_for_submission(data, form_id="md01maritalStatus")
            # No exception - data is valid
        """
        invalid_fields = set(data.keys()) & INFRASTRUCTURE_FIELDS
        if invalid_fields:
            raise ValidationError(
                f"Data for {form_id} contains infrastructure fields "
                f"that Joget auto-generates: {', '.join(sorted(invalid_fields))}. "
                f"Remove these fields: {INFRASTRUCTURE_FIELDS}"
            )
